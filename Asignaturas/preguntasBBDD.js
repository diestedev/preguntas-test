window.allQuestions = [
  {
    q: "¿Cómo podemos representar y definir los datos en un sistema de información sin tener en cuenta las necesidades tecnológicas?",
    options: [
      "Con un diagrama entidad/relación",
      "Con el diccionario de datos",
      "Con Pseudocódigo",
      "Con un diagrama de cardinalidad",
    ],
    correct: 0,
    explanation: "El DER permite representar datos sin depender de tecnología.",
  },
  {
    q: "¿En qué bloque se incluyen las sentencias y estructuras de la lógica del procedimiento?",
    options: [
      "En el bloque DECLARE",
      "En el bloque BEGIN",
      "En el bloque EXCEPTION",
      "Después de END",
    ],
    correct: 1,
    explanation: "BEGIN contiene la lógica ejecutable.",
  },
  {
    q: "¿Para qué sirven los índices?",
    options: [
      "Para saber el número de entidades que hay",
      "Representa un índice de objetos de los metadatos",
      "Permiten agilizar el acceso a un campo mediante la organización de su información",
      "Define la clave primaria de una entidad",
    ],
    correct: 2,
    explanation: "Los índices aceleran las búsquedas.",
  },
  {
    q: "¿PL/SQL es compatible con todos los SGBD?",
    options: [
      "Sí, hay un estándar de aplicación",
      "Sí, contiene estructuras que entienden todos los SGBD",
      "Sí",
      "No, PL/SQL sirve para Oracle y PL/pgSQL para PostgreSQL",
    ],
    correct: 3,
    explanation: "Cada SGBD tiene su propio lenguaje procedimental.",
  },
  {
    q: "¿Qué condición tiene que cumplir en la segunda forma normal (2FN)?",
    options: [
      "Puede tener valores atómicos",
      "Debe estar en la primera forma normal",
      "Sus campos no dependen de la clave primaria",
      "Debe estar en la tercera forma normal",
    ],
    correct: 1,
    explanation: "2FN exige cumplir 1FN.",
  },
  {
    q: "¿Qué debemos tener en cuenta en la gestión de fallos lógicos en una base de datos?",
    options: [
      "Controlar los accesos a los servicios y recursos de las bases de datos",
      "Autenticación en el SGBD",
      "Gestión de perfiles y usuarios",
      "Todas son correctas",
    ],
    correct: 3,
    explanation: "Los fallos lógicos requieren control de accesos y usuarios.",
  },
  {
    q: "¿Qué es un sistema gestor de base de datos?",
    options: [
      "Un tipo de base de datos",
      "Un software con herramientas de administración y gestión de base de datos",
      "Un software para programar una base de datos",
      "Un software de diseño de base de datos",
    ],
    correct: 1,
    explanation: "Un SGBD administra y gestiona bases de datos.",
  },
  {
    q: "¿Qué instrucción necesitamos para ver la estructura de una tabla?",
    options: ["DESC", "ESTRUCT", "SHOW TABLES", "SHOW DATABASES"],
    correct: 0,
    explanation: "DESC muestra la estructura de una tabla.",
  },
  {
    q: "¿Qué instrucción nos permite modificar una tabla?",
    options: ["INSERT", "UPDATE", "DROP TABLE", "ALTER TABLE"],
    correct: 3,
    explanation: "ALTER TABLE modifica la estructura de una tabla.",
  },
  {
    q: "Bucle preparado con un número de repeticiones predeterminadas:",
    options: [
      "Bucle básico LOOP",
      "Bucle con WHILE",
      "Bucle FOR",
      "Bucle ELSE",
    ],
    correct: 2,
    explanation: "FOR ejecuta un número predeterminado de iteraciones.",
  },
  {
    q: "CREATE DATABASE nombre_bd; permite crear una base de datos empleando el lenguaje:",
    options: ["DDL", "DML", "DCL", "Todas las anteriores son incorrectas"],
    correct: 0,
    explanation: "CREATE DATABASE pertenece a DDL.",
  },
  {
    q: "Cuando hablamos de integridad referencial...",
    options: [
      "No podemos borrar un registro que está relacionado con otra mediante su clave foránea",
      "Cualquier cambio en un registro que está relacionado se trasmite en cascada",
      "Establecer valores nulos en claves foráneas",
      "Todas son correctas",
    ],
    correct: 3,
    explanation: "La integridad referencial controla relaciones entre tablas.",
  },
  {
    q: "Cuando se almacena una dirección o puntero en vez del valor de la información, estamos hablando de:",
    options: ["Datos físicos", "Referencias", "Herencia", "Datos extrapolados"],
    correct: 1,
    explanation: "Una referencia almacena un puntero a datos.",
  },
  {
    q: "Cuando tenemos una transferencia de datos entre distintos SGBD:",
    options: [
      "No hay que preocuparse todos los SGDB tienen las mismas características",
      "Un tipo de datos se usa igual independientemente del SGBD",
      "Solo se puede hacer entre el mismo tipo de base de datos",
      "Es una tarea importante, cada SGBD tiene diferentes características y hay que adaptarlas según el cambio",
    ],
    correct: 3,
    explanation: "Cada SGBD maneja tipos y estructuras diferentes.",
  },
  {
    q: "El lenguaje más empleado en bases de datos es:",
    options: ["SUL", "SDL", "SFL", "SQL"],
    correct: 3,
    explanation: "SQL es el estándar de bases de datos.",
  },
  {
    q: "Es el lenguaje que usaremos para administrar la seguridad de los datos mediante permisos y usuarios:",
    options: ["DDL", "DML", "DCL", "Todas las anteriores son incorrectas"],
    correct: 2,
    explanation: "DCL gestiona permisos y usuarios.",
  },
  {
    q: "Es un tipo de copia de seguridad:",
    options: ["Incompletas", "Decrementales", "Incrementales", "Existenciales"],
    correct: 2,
    explanation: "Las copias incrementales guardan solo cambios.",
  },
  {
    q: "Es un tipo de modelo de base de datos:",
    options: [
      "Modelo relacional",
      "Modelo en red",
      "Modelo orientado a objetos",
      "Todas son correctas",
    ],
    correct: 3,
    explanation: "Existen múltiples modelos de BD.",
  },
  {
    q: "Es un tipo de organización de los soportes de almacenamiento:",
    options: ["Secuencial", "Aleatorio", "Multiplexado", "Concatenado"],
    correct: 0,
    explanation: "La organización secuencial es clásica en almacenamiento.",
  },
  {
    q: "Es un tipo de relación:",
    options: ["Comunicativas", "Reflexivas", "Concatenarías", "Expresivas"],
    correct: 1,
    explanation: "Las relaciones reflexivas se refieren a sí mismas.",
  },
  {
    q: "Es una consecuencia de las bases de datos objeto-relacionales:",
    options: [
      "Que no tengamos campos atómicos",
      "Que las tablas no sean elementos bidimensionales",
      "A y B son correctas",
      "Todas son incorrectas",
    ],
    correct: 2,
    explanation: "Los modelos ORDB permiten estructuras complejas.",
  },
  {
    q: "Es una función de agregación o resumen:",
    options: ["RESTA()", "MOD()", "TOTAL()", "COUNT()"],
    correct: 3,
    explanation: "COUNT() cuenta registros.",
  },
  {
    q: "Estructura de control que emplea las sentencias IF y CASE:",
    options: [
      "Selección",
      "Iteración",
      "Segmentación",
      "Todas las anteriores son incorrectas",
    ],
    correct: 0,
    explanation: "IF y CASE son estructuras de selección.",
  },
  {
    q: "Existen dos tipos de clave, la primaria y:",
    options: [
      "La secundaria",
      "La exclusiva",
      "La jerarquizada",
      "La candidata",
    ],
    correct: 3,
    explanation: "Las claves candidatas pueden ser primarias.",
  },
  {
    q: "La clave primaria:",
    options: [
      "Puede ser única",
      "Puede estar formada por un único campo o ser compuesta",
      "Se deriva de la clave secundaria",
      "Ninguna de las anteriores",
    ],
    correct: 1,
    explanation: "Una clave primaria puede ser compuesta.",
  },
  {
    q: "La POO sirve para:",
    options: [
      "Que otros paradigmas se basen en esta",
      "Desarrollar solo software privativo",
      "Fallos de software",
      "Todas son incorrectas",
    ],
    correct: 0,
    explanation: "La POO es base de muchos paradigmas modernos.",
  },
  {
    q: "La sentencia UPDATE nos permite:",
    options: [
      "La consulta de registros sobre varias tablas",
      "La Eliminación de registros",
      "La modificación de registros",
      "Ninguna de las anteriores es correcta",
    ],
    correct: 2,
    explanation: "UPDATE modifica registros existentes.",
  },
  {
    q: "Lenguaje que se centra en la consulta de información:",
    options: ["DDL", "DML", "DCL", "Ninguna de las anteriores"],
    correct: 1,
    explanation: "DML manipula datos, incluyendo SELECT.",
  },
  {
    q: "Lo que en un modelo entidad/relación es una entidad, en un modelo físico es llamado:",
    options: ["Registro", "Entidad", "Tabla", "Tipo"],
    correct: 2,
    explanation: "Una entidad se convierte en tabla.",
  },
  {
    q: "Los fallos lógicos:",
    options: [
      "Son los que se producen por fallos de software",
      "Un virus es un fallo lógico",
      "A y B son correctas",
      "Son los que se producen por fallos de hardware",
    ],
    correct: 2,
    explanation: "Los fallos lógicos no son físicos.",
  },
  {
    q: "Los ficheros:",
    options: [
      "Tienen su propio sistema de escritura",
      "Contienen texto plano",
      "Contienen código binario",
      "Puede contener tanto texto plano como binario",
    ],
    correct: 3,
    explanation: "Un fichero puede contener texto o binario.",
  },
  {
    q: "M:N es un concepto de:",
    options: [
      "Las claves",
      "La cardinalidad",
      "La modalidad",
      "Multidimensional",
    ],
    correct: 1,
    explanation: "M:N indica cardinalidad muchos a muchos.",
  },
  {
    q: "MySQL es:",
    options: [
      "Un sublenguaje de SQL",
      "Un tipo de base de datos",
      "Un SGBD",
      "Ninguna de las anteriores",
    ],
    correct: 2,
    explanation: "MySQL es un sistema gestor de bases de datos.",
  },
  {
    q: "Para buscar un patrón de una cadena de caracteres usaremos...",
    options: [
      "Se incluirá todos los casos posibles y se unirán con el operador lógico AND",
      "BETWEEN",
      "LIKE",
      "No se puede buscar patrones de cadenas de caracteres",
    ],
    correct: 2,
    explanation: "LIKE permite buscar patrones.",
  },
  {
    q: "Para solucionar un fallo físico:",
    options: [
      "Podemos tirar todo y comprar nuevos equipos",
      "La gestión de los backups es una buena opción",
      "No es necesario recuperar un fallo físico",
      "Todas las anteriores son correctas",
    ],
    correct: 1,
    explanation: "Los backups permiten recuperar fallos físicos.",
  },
  {
    q: "PL/SQL no puede soportar:",
    options: [
      "DDL",
      "DML",
      "Los dos anteriores",
      "Todas las anteriores son incorrectas",
    ],
    correct: 0,
    explanation: "PL/SQL no ejecuta DDL directamente.",
  },
  {
    q: "Se pueden usar para los subtipos y supertipos las cláusulas:",
    options: [
      "NOT FINAL",
      "FINAL",
      "UNDER",
      "Todas las anteriores son correctas",
    ],
    correct: 3,
    explanation: "Todas se usan en herencia de tipos.",
  },
  {
    q: "Si queremos seleccionar unos datos y que no estén repetidos...",
    options: [
      "Tenemos que preocuparnos de insertar los datos que no estén repetidos",
      "Hay que incluir DISTINCT",
      "En las bases de datos relacionales esto no puede suceder",
      "Se utilizará el operador <>",
    ],
    correct: 1,
    explanation: "DISTINCT elimina duplicados.",
  },
  {
    q: "Un tipo que puede almacenar una colección es considerado como:",
    options: ["Array", "Tablas", "Columnas", "Filas"],
    correct: 0,
    explanation: "Un array almacena colecciones.",
  },
  {
    q: "UNIQUE es:",
    options: [
      "Una restricción en SQL que se utiliza para garantizar que no se inserten valores duplicados en una columna",
      "Una restricción en SQL que se utiliza para garantizar los valores tipo NULL",
      "Una restricción en SQL que se utiliza para garantizar que no se inserten valores con un formato diferente al destinado",
      "Ninguna de las anteriores",
    ],
    correct: 0,
    explanation: "UNIQUE evita valores duplicados.",
  },
  {
    q: "El mayor problema de la indexación es:",
    options: [
      "Que requiere de más espacio",
      "Que al actualizarse automáticamente puede cometer fallos",
      "Que no se actualiza automáticamente, por lo que resulta laboroso mantenerlo actualizado",
      "Ninguna de las anteriores",
    ],
    correct: 2,
    explanation: "Los índices deben mantenerse actualizados.",
  },
  {
    q: "El modelo de red:",
    options: [
      "Mejora la flexibilidad del jerárquico",
      "Introdujo una multitud de novedades",
      "Poseía una complejidad considerable",
      "Todas las anteriores son ciertas",
    ],
    correct: 3,
    explanation: "El modelo en red era potente pero complejo.",
  },
  {
    q: "El modelo relacional se ha fusionado con este para crear el más usado hoy:",
    options: [
      "Jerárquico",
      "Indexado",
      "Orientado a objetos",
      "Multidimensional",
    ],
    correct: 2,
    explanation: "El modelo ORDB combina relacional y objetos.",
  },
  {
    q: "El soporte de datos direccionable permite:",
    options: [
      "La lectura solo secuencial",
      "La lectura desde el dato deseado",
      "Almacenamiento jerárquico indexado",
      "No existe este tipo de soporte",
    ],
    correct: 1,
    explanation: "Direccionable = acceso directo.",
  },
  {
    q: "La codificación más común en texto plano es:",
    options: ["UTF8 o UTF16", "UTF12 o UTF24", "UTF8 o UTF24", "UTF12 o UTF16"],
    correct: 0,
    explanation: "UTF-8 y UTF-16 son estándares.",
  },
  {
    q: "La indexación permite:",
    options: [
      "Mayor almacenamiento",
      "Una búsqueda más eficiente",
      "Registro automático",
      "Ninguna de las anteriores",
    ],
    correct: 1,
    explanation: "Los índices aceleran búsquedas.",
  },
  {
    q: "Los ficheros:",
    options: [
      "Tienen su propio sistema de escritura",
      "Contienen texto plano",
      "Contienen código binario",
      "Pueden contener tanto texto plano como binario",
    ],
    correct: 3,
    explanation: "Un fichero puede contener ambos.",
  },
  {
    q: "Podemos encontrar punteros en:",
    options: [
      "Ficheros secuenciales",
      "Bases de datos jerárquicas",
      "Ficheros secuenciales encadenados",
      "Bases de datos objetorelacional",
    ],
    correct: 2,
    explanation: "Los ficheros encadenados usan punteros.",
  },
  {
    q: "Un fichero secuencial encadenado:",
    options: [
      "Posee un índice",
      "Posee doble ordenación: secuencial y lógica",
      "Permite ordenación por objetos",
      "Ninguna de las anteriores",
    ],
    correct: 1,
    explanation: "Tiene orden físico y lógico.",
  },
  {
    q: "Un fichero secuencial encadenado:",
    options: [
      "Posee un índice",
      "Posee doble ordenación: secuencial y lógica",
      "Permite ordenación por objetos",
      "Ninguna de las anteriores",
    ],
    correct: 1,
    explanation: "Tiene orden físico y lógico.",
  },
  {
    q: "Es la modalidad que implica una única ocurrencia siempre:",
    options: ["0,1", "1,1", "1,N", "0,N"],
    correct: 1,
    explanation: "1,1 implica obligatoriedad y unicidad.",
  },
  {
    q: "Existen dos tipos de clave, la primaria y:",
    options: [
      "La secundaria",
      "La exclusiva",
      "La jerarquizada",
      "La candidata",
    ],
    correct: 3,
    explanation: "Las claves candidatas pueden ser primarias.",
  },
  {
    q: "La clave primaria se marca con:",
    options: [
      "Un círculo relleno",
      "Un círculo en blanco",
      "Un rombo en blanco",
      "Un rombo relleno",
    ],
    correct: 0,
    explanation: "En algunos DER se marca con círculo relleno.",
  },
  {
    q: "La clave primaria:",
    options: [
      "Puede ser única",
      "Puede estar formada por un único campo o ser compuesta",
      "Se deriva de la clave secundaria",
      "Ninguna de las anteriores",
    ],
    correct: 1,
    explanation: "Puede ser simple o compuesta.",
  },
  {
    q: "¿Cómo surge la modalidad?",
    options: [
      "A partir de toda la relación de las entidades",
      "A partir de los mínimos y máximos de las ocurrencias de cada entidad",
      "A partir del número de atributos",
      "Ninguna de las anteriores",
    ],
    correct: 1,
    explanation: "La modalidad depende de mínimos y máximos.",
  },
  {
    q: "La relación Narias indica una relación entre:",
    options: [
      "5 entidades o más",
      "Cualquier número de entidades",
      "4 entidades o más",
      "Ninguna de las anteriores",
    ],
    correct: 2,
    explanation: "N-arias implica 4 o más entidades.",
  },
  {
    q: "Las instancias se extraen de:",
    options: [
      "Las relaciones",
      "Las entidades",
      "La modalidad",
      "Ninguna de las anteriores",
    ],
    correct: 1,
    explanation: "Las entidades generan instancias.",
  },
  {
    q: "Las ternarias son:",
    options: [
      "Elementos de cardinalidad",
      "Elementos de modalidad",
      "Elementos de entidades",
      "Todas las anteriores son incorrectas",
    ],
    correct: 3,
    explanation: "Una relación ternaria es un tipo de relación.",
  },
  {
    q: "M:N es un concepto de:",
    options: [
      "Las claves",
      "La cardinalidad",
      "La modalidad",
      "Multidimensional",
    ],
    correct: 1,
    explanation: "M:N indica cardinalidad.",
  },
  {
    q: "Un profesor que imparte clase a diversos alumnos formaría una relación:",
    options: ["M:N", "1:N", "N:M", "1:1"],
    correct: 1,
    explanation: "Un profesor → muchos alumnos.",
  },
  {
    q: "1FN busca introducir valores:",
    options: [
      "Duplicados",
      "Numéricos",
      "Atómicos",
      "Ninguna de las anteriores",
    ],
    correct: 2,
    explanation: "1FN exige valores atómicos.",
  },
  {
    q: "DER son las siglas de:",
    options: [
      "Diagrama de Entidad/Relación",
      "Diacronía entidad/relación",
      "Diseño entidad/relación",
      "Ninguna de las anteriores",
    ],
    correct: 0,
    explanation: "DER = Diagrama Entidad–Relación.",
  },
  {
    q: "El valor NULL:",
    options: [
      "Indica el valor 0",
      "Indica un valor indeterminado",
      "Indica el valor nulo",
      "Todas las anteriores son incorrectas",
    ],
    correct: 2,
    explanation: "NULL representa ausencia de valor.",
  },
  {
    q: "En el modelo físico los valores lógicos se marcan con el prefijo:",
    options: ["V", "v", "L", "l"],
    correct: 3,
    explanation: "Se usa 'l' para valores lógicos.",
  },
  {
    q: "La integridad referencial se puede mantener empleando:",
    options: [
      "Prohibiciones a ciertas operaciones",
      "Transmisión en cascada",
      "Valores por defecto",
      "Todas las anteriores son correctas",
    ],
    correct: 3,
    explanation: "Todas son técnicas válidas.",
  },
  {
    q: "Política de bloqueo que permite consultar el valor bloqueado pero no modificarlo:",
    options: ["Exclusivas", "Compartidos", "Prohibitivos", "Relacional"],
    correct: 1,
    explanation: "El bloqueo compartido permite lectura.",
  },
  {
    q: "Lo que en un modelo entidadrelación es una entidad, en el modelo físico es:",
    options: ["Registro", "Entidad", "Tabla", "Tipo"],
    correct: 2,
    explanation: "Entidad → tabla.",
  },
  {
    q: "Los identificadores siempre emplean:",
    options: ["El prefijo I", "El prefijo ID", "El sufijo I", "El sufijo ID"],
    correct: 3,
    explanation: "Se usa sufijo ID.",
  },
  {
    q: "Podemos encontrar un total de:",
    options: [
      "2 Formas Normales",
      "3 Formas Normales",
      "5 Formas Normales",
      "6 Formas Normales",
    ],
    correct: 3,
    explanation: "Existen 6 FN clásicas.",
  },
  {
    q: "UNIQUE es:",
    options: [
      "Una restricción en SQL que garantiza que no se inserten valores duplicados en una columna",
      "Una restricción para garantizar valores NULL",
      "Una restricción para garantizar formato correcto",
      "Ninguna de las anteriores",
    ],
    correct: 0,
    explanation: "UNIQUE evita duplicados.",
  },
  {
    q: "Boolean es un tipo de dato de:",
    options: [
      "Números exactos",
      "Números aproximados",
      "Valor lógico",
      "Ninguna de las anteriores",
    ],
    correct: 2,
    explanation: "BOOLEAN representa valores lógicos.",
  },
  {
    q: "CLOB es un tipo de dato de:",
    options: [
      "Números exactos",
      "Números aproximados",
      "Valor lógico",
      "Ninguna de las anteriores",
    ],
    correct: 3,
    explanation: "CLOB almacena texto muy largo.",
  },
  {
    q: "CREATE DATABASE nombre_bd; pertenece al lenguaje:",
    options: ["DDL", "DML", "DCL", "Todas las anteriores son incorrectas"],
    correct: 0,
    explanation: "CREATE DATABASE es DDL.",
  },
  {
    q: "Lenguaje usado para administrar seguridad, permisos y usuarios:",
    options: ["DDL", "DML", "DCL", "Todas las anteriores son incorrectas"],
    correct: 2,
    explanation: "DCL gestiona permisos.",
  },
  {
    q: "Es un sublenguaje de SQL:",
    options: ["DDL", "DML", "DCL", "Todas las anteriores son correctas"],
    correct: 3,
    explanation: "SQL incluye DDL, DML y DCL.",
  },
  {
    q: "MySQL es:",
    options: [
      "Un sublenguaje de SQL",
      "Un tipo de base de datos",
      "Un SGBD",
      "Ninguna de las anteriores",
    ],
    correct: 2,
    explanation: "MySQL es un SGBD.",
  },
  {
    q: "Tipo de dato que almacena imágenes, documentos, etc. en binario:",
    options: ["SMALLINT", "BLOB", "REAL", "Ninguna de las anteriores"],
    correct: 1,
    explanation: "BLOB almacena binarios.",
  },
  {
    q: "Tipo de dato que almacena la hora (hh:mm:ss):",
    options: ["TIME", "TIMESTAMP", "INTERVAL", "Ninguna de las anteriores"],
    correct: 0,
    explanation: "TIME almacena horas.",
  },
  {
    q: "Tipo de dato que rellena con espacios hasta su longitud definida:",
    options: ["CHAR", "VARCHAR", "CLOB", "BLOB"],
    correct: 0,
    explanation: "CHAR es de longitud fija.",
  },
  {
    q: "VARCHAR(60) es un tipo de dato para:",
    options: [
      "Caracteres",
      "Números exactos",
      "Números aproximados",
      "Ninguna de las anteriores",
    ],
    correct: 0,
    explanation: "VARCHAR almacena texto variable.",
  },
  {
    q: "Emplea la sentencia SELECT para la selección de tablas:",
    options: ["DDL", "DML", "DCL", "Ninguna de las anteriores"],
    correct: 1,
    explanation: "SELECT pertenece a DML.",
  },
  {
    q: "INSERT es:",
    options: [
      "Un privilegio que se nos puede otorgar",
      "Un tipo de vista",
      "Las dos anteriores son correctas",
      "Todas las anteriores son incorrectas",
    ],
    correct: 0,
    explanation: "INSERT puede ser un privilegio.",
  },
  {
    q: "IS NULL permite:",
    options: [
      "Asignar el valor NULL",
      "No asignar ningún valor",
      "Comprobar si el valor es NULL",
      "BLOB",
    ],
    correct: 2,
    explanation: "IS NULL comprueba valores nulos.",
  },
  {
    q: "La función integrada ABS devuelve:",
    options: [
      "El valor absoluto del número",
      "Valor con decimales",
      "Resultado de una división",
      "Todas las anteriores son incorrectas",
    ],
    correct: 0,
    explanation: "ABS devuelve el valor absoluto.",
  },
  {
    q: "La inserción de registros se puede realizar con la sentencia:",
    options: ["SELECT", "UPDATE", "DELETE", "Ninguna de las anteriores"],
    correct: 3,
    explanation: "INSERT es la sentencia correcta.",
  },
  {
    q: "La sentencia UPDATE permite:",
    options: [
      "Consultar registros sobre varias tablas",
      "Eliminar registros",
      "Modificar registros",
      "Ninguna de las anteriores",
    ],
    correct: 2,
    explanation: "UPDATE modifica registros.",
  },
  {
    q: "Lenguaje que se centra en la consulta de información:",
    options: ["DDL", "DML", "DCL", "Ninguna de las anteriores"],
    correct: 1,
    explanation: "DML incluye SELECT.",
  },
  {
    q: "Para designar un alias se emplea el operador:",
    options: ["AND", "OR", "AS", "Todas las anteriores son incorrectas"],
    correct: 2,
    explanation: "AS define alias.",
  },
  {
    q: "WITH GRANT OPTION se emplea en:",
    options: ["DDL", "DML", "DCL", "Ninguna de las anteriores"],
    correct: 2,
    explanation: "DCL gestiona privilegios.",
  },
  {
    q: "WITH GRANT OPTION:",
    options: [
      "Otorga el privilegio SELECT",
      "Revoca privilegios",
      "Otorga el derecho a otorgar derechos",
      "Ninguna de las anteriores",
    ],
    correct: 2,
    explanation: "Permite otorgar privilegios a otros usuarios.",
  },
  {
    q: "Bucle preparado con un número de repeticiones predeterminadas:",
    options: [
      "Bucle básico LOOP",
      "Bucle con WHILE",
      "Bucle FOR",
      "Bucle ELSE",
    ],
    correct: 2,
    explanation: "El bucle FOR ejecuta un número fijo de iteraciones.",
  },
  {
    q: "El operador || determina la:",
    options: [
      "Potencia",
      "Raíz",
      "Concatenación",
      "Todas las anteriores son incorrectas",
    ],
    correct: 2,
    explanation: "|| concatena cadenas.",
  },
  {
    q: "En una operación lógica con OR, si A = TRUE y B = FALSE, el resultado es:",
    options: ["TRUE", "FALSE", "NULL", "No se puede realizar"],
    correct: 0,
    explanation: "TRUE OR FALSE = TRUE.",
  },
  {
    q: "Es un carácter de longitud variable:",
    options: ["CHAR", "CHARVAR", "VARCHAR2", "Ninguna de las anteriores"],
    correct: 2,
    explanation: "VARCHAR2 almacena texto variable.",
  },
  {
    q: "Estructura de control que emplea IF y CASE:",
    options: [
      "Selección",
      "Iteración",
      "Segmentación",
      "Todas las anteriores son incorrectas",
    ],
    correct: 0,
    explanation: "IF y CASE son estructuras de selección.",
  },
  {
    q: "Estructura lógica que realiza una acción hasta que un valor booleano cambie:",
    options: [
      "Secuencia",
      "Iteración",
      "Segmentación",
      "Ninguna de las anteriores",
    ],
    correct: 1,
    explanation: "La iteración repite hasta que cambie la condición.",
  },
  {
    q: "Los bloques se ejecutan con el carácter:",
    options: ["/", "$", "Ninguna de las anteriores"],
    correct: 0,
    explanation: "En PL/SQL se ejecutan con /",
  },
  {
    q: "Operador de negación lógica:",
    options: ["--", "=-", "+--", "Todas las anteriores son incorrectas"],
    correct: 3,
    explanation: "El operador correcto es NOT.",
  },
  {
    q: "PL/SQL no puede soportar:",
    options: [
      "DDL",
      "DML",
      "Los dos anteriores",
      "Todas las anteriores son incorrectas",
    ],
    correct: 0,
    explanation: "PL/SQL no ejecuta DDL directamente.",
  },
  {
    q: "Un LOOP es:",
    options: [
      "Una excepción",
      "Una invocación",
      "Una función",
      "Ninguna de las anteriores",
    ],
    correct: 3,
    explanation: "LOOP es una estructura de control.",
  },
  {
    q: "Es un fallo físico:",
    options: [
      "Avería en un servidor",
      "Problema con el suministro eléctrico",
      "Robo",
      "Todas son correctas",
    ],
    correct: 3,
    explanation: "Todos son fallos físicos.",
  },
  {
    q: "La principal clasificación de fallos en bases de datos se distingue en:",
    options: [
      "Fallos físicos y químicos",
      "Fallos físicos y lógicos",
      "Fallos de software y aplicaciones",
      "Todas son incorrectas",
    ],
    correct: 1,
    explanation: "La clasificación estándar es física/lógica.",
  },
  {
    q: "La restauración:",
    options: [
      "Remodelación de dispositivos",
      "Recuperación de datos desde una copia de seguridad",
      "Fin del ciclo de vida de una BD",
      "Técnica de inserción de datos",
    ],
    correct: 1,
    explanation: "Restaurar = recuperar desde backup.",
  },
  {
    q: "Las copias de seguridad:",
    options: [
      "Son un respaldo de la información",
      "Se pueden recuperar en caso de fallo",
      "A y B son correctas",
      "Todas las anteriores son incorrectas",
    ],
    correct: 2,
    explanation: "Las copias permiten recuperar datos.",
  },
  {
    q: "Las copias de seguridad pueden ser:",
    options: [
      "Borradas cada dos días",
      "Hechas a mano",
      "Invisibles o espejadas",
      "Todas son incorrectas",
    ],
    correct: 3,
    explanation: "Las opciones dadas no son tipos reales.",
  },
  {
    q: "Las copias de seguridad:",
    options: [
      "Se dividen en completas e incompletas",
      "No se pueden realizar en una BD",
      "Son una mala gestión de seguridad",
      "Todas son incorrectas",
    ],
    correct: 3,
    explanation:
      "La clasificación correcta es completa/incremental/diferencial.",
  },
  {
    q: "Los fallos lógicos:",
    options: [
      "Se producen por fallos de software",
      "Un virus es un fallo lógico",
      "A y B son correctas",
      "Se producen por fallos de hardware",
    ],
    correct: 2,
    explanation: "Los fallos lógicos no son físicos.",
  },
  {
    q: "Los tipos de datos de una base de datos:",
    options: [
      "Pueden diferenciarse según el sistema usado",
      "Son iguales en todos los SGBD",
      "No se deben tener en cuenta en traspasos",
      "Todas son correctas",
    ],
    correct: 0,
    explanation: "Cada SGBD tiene tipos propios.",
  },
  {
    q: "Para restaurar un backup:",
    options: [
      "Restaurar lo que no queramos tener",
      "Eliminar todas las copias",
      "Restaurar primero la última copia de seguridad total",
      "Ninguna es correcta",
    ],
    correct: 2,
    explanation: "Primero se restaura la copia completa.",
  },
  {
    q: "Para solucionar un fallo físico:",
    options: [
      "Tirar todo y comprar equipos nuevos",
      "Gestionar correctamente los backups",
      "No es necesario recuperarlo",
      "Todas las anteriores son correctas",
    ],
    correct: 1,
    explanation: "Los backups permiten recuperar fallos físicos.",
  },
  {
    q: "¿Qué cláusula se usa únicamente en la herencia de los subtipos?",
    options: ["UNDER", "NOT FINAL", "SELF", "NOT LIKE"],
    correct: 0,
    explanation: "UNDER se usa para herencia en tipos.",
  },
  {
    q: "¿Qué es una referencia en bases de datos?",
    options: [
      "Un puntero con un identificador (OID) que dirige a la información u otros objetos",
      "Elemento donde la tabla guarda info de otras tablas",
      "Elemento con datos de usuario",
      "Ninguna es correcta",
    ],
    correct: 0,
    explanation: "Una referencia apunta a un objeto mediante OID.",
  },
  {
    q: "El modelo relacional anidado:",
    options: [
      "No existe",
      "Valores únicos por tabla",
      "Valores compartidos con solo otra tabla",
      "Valores compartidos con varias tablas",
    ],
    correct: 3,
    explanation: "El modelo anidado permite estructuras complejas.",
  },
  {
    q: "El paradigma de la programación orientada a objetos:",
    options: [
      "Surge en los noventa",
      "Simplifica SELECT",
      "Busca mayor calidad de código",
      "Todas son correctas",
    ],
    correct: 3,
    explanation: "La POO mejora calidad y estructura del código.",
  },
  {
    q: "Consecuencia de las bases de datos objetorelacionales:",
    options: [
      "No tener campos atómicos",
      "Tablas no bidimensionales",
      "A y B son correctas",
      "Todas son incorrectas",
    ],
    correct: 2,
    explanation: "Las ORDB permiten estructuras no atómicas.",
  },
  {
    q: "Afirmación falsa sobre la herencia:",
    options: [
      "Se puede extrapolar a BD",
      "Comprende clases base y extendida",
      "No tiene sentido en las bases de datos",
      "Puede ser múltiple",
    ],
    correct: 2,
    explanation: "La herencia sí tiene sentido en BD OR.",
  },
  {
    q: "La POO sirve para:",
    options: [
      "Que otros paradigmas se basen en esta",
      "Desarrollar solo software privativo",
      "Fallos de software",
      "Todas son incorrectas",
    ],
    correct: 0,
    explanation: "La POO es base de muchos paradigmas.",
  },
  {
    q: "Los tipos complejos:",
    options: [
      "No se pueden crear",
      "Incompatibles con arrays",
      "Solo sirven para un campo",
      "Todas son incorrectas",
    ],
    correct: 3,
    explanation: "Los tipos complejos sí se pueden crear y usar.",
  },
  {
    q: "Cláusulas para subtipos y supertipos:",
    options: [
      "NOT FINAL",
      "FINAL",
      "UNDER",
      "Todas las anteriores son correctas",
    ],
    correct: 3,
    explanation: "Todas se usan en herencia de tipos.",
  },
  {
    q: "Un array es:",
    options: [
      "Una colección de datos",
      "Un tipo obsoleto",
      "Un elemento único de BD",
      "Todas son incorrectas",
    ],
    correct: 0,
    explanation: "Un array almacena colecciones.",
  },
];
